在阎宏博士的《JAVA与模式》一书中开头是这样描述原型（Prototype）模式的：
	原型模式属于对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出
	更多同类型的对象。这就是选型模式的用意。
	
原型模式的结构
	原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。这样一来，通
	过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身的方法，就可以通过这个方法来获取新的对
	象，而无须再去通过new来创建。
	原型模式有两种表现形式：（1）简单形式、（2）登记形式，这两种表现形式仅仅是原型模式的不同实现。
	
这种形式涉及到三个角色：
　　（1）客户(Client)角色：客户类提出创建对象的请求。
　　（2）抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。
		此角色给出所有的具体原型类所需的接口。
　　（3）具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口


Java中的克隆方法
	Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复
	制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的
	对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份
	
	Java语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过
	调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现
	Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。

克隆满足的条件
	clone()方法将对象复制了一份并返还给调用者。所谓“复制”的含义与clone()方法是怎么实现的。一般而言，clone()方法满足
	以下的描述：
		（1）对任何的对象x，都有：x.clone()!=x。换言之，克隆对象与原对象不是同一个对象。
		（2）对任何的对象x，都有：x.clone().getClass() == x.getClass()，换言之，克隆对象与原对象的类型一样。
		（3）如果对象x的equals()方法定义其恰当的话，那么x.clone().equals(x)应当成立的。
	
	在JAVA语言的API中，凡是提供了clone()方法的类，都满足上面的这些条件。JAVA语言的设计师在设计自己的clone()方法时，
	也应当遵守着三个条件。一般来说，上面的三个条件中的前两个是必需的，而第三个是可选的。

浅克隆和深克隆
	无论你是自己实现克隆方法，还是采用Java提供的克隆方法，都存在一个浅度克隆和深度克隆的问题。
	浅度克隆
		只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用
		都仍然指向原来的对象。
	深度克隆
		除了浅度克隆要克隆的值外，还负责克隆引用类型的数据。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那
		些被引用的对象。换言之，深度克隆把要复制的对象所引用的对象都复制了一遍，而这种对被引用到的对象的复制叫做间接复制。
	深度克隆要深入到多少层，是一个不易确定的问题。在决定以深度克隆的方式复制一个对象的时候，必须决定对间接复制的对象时采取浅
	度克隆还是继续采用深度克隆。因此，在采取深度克隆时，需要决定多深才算深。此外，在深度克隆的过程中，很可能会出现循环引用的
	问题，必须小心处理。

利用序列化实现深度克隆
	把对象写到流里的过程是序列化(Serialization)过程；而把对象从流中读出来的过程则叫反序列化(Deserialization)过程。应当
	指出的是，写到流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。	


参考链接：http://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html




	
	
	